@0x00   0x07 //goto init vga
@0x01   0x4A
//=====================
// PART A: Mouse/IR Section
//=====================
@0x02   0x02 // Write Status Byte to LED memory
@0x03   0xC0
@0x04   0x00 // Read Switch byte into reg A
@0x05   0x80
@0x06   0x00
@0x07   0x80
@0x08   0x02 // Write Switch Byte to ir memory
@0x09   0x91
@0x0A   0x00 // Read MouseX Byte into reg A
@0x0B   0xA1
@0x0C   0x01 // Read MouseY Byte into reg B
@0x0D   0xA2
@0x0E   0x02 // Save MouseX Byte to RAM
@0x0F   0x00
@0x10   0x03 // Save MouseY Byte to RAM
@0x11   0x01
@0x12   0x02 // Write MouseX byte to 7-seg mem base address
@0x13   0xD0
@0x14   0x03 // Write MouseY byte to 7-seg mem base address
@0x15   0xD1
// X position check stage 1 //
@0x16   0x00 // Read saved mouse X from RAM into reg A (to be deleted)
@0x17   0x00
@0x18   0x01 // Read first XBoundary from RAM into reg B
@0x19   0x07
//// if X > first block?
@0x1A   0xA6 // True: branch to stage 2
@0x1B   0x22
@0x1C   0x01 // False: load left code into reg B
@0x1D   0x04
@0x1E   0x03 // False: write reg B (left) value to op code
@0x1F   0x0B
@0x20   0x07 // False: goto Y position check stage 1
@0x21   0x2A
// X position check stage 2 // 
@0x22   0x01 // Read second XBoundary from RAM into reg B
@0x23   0x08
//// if X < third block?  
@0x24   0xB6 // True: maintain op code 0 and branch to Y position check stage 1
@0x25   0x2A
@0x26   0x01 // False: load right code into reg B
@0x27   0x05
@0x28   0x03 // False: write reg B (Right) value to op code
@0x29   0x0B
////// False: goto Y position check stage 1
// Y position check stage 1 //
@0x2A   0x00 // Read saved mouse Y from RAM into reg A
@0x2B   0x01
@0x2C   0x01 // Read first YBoundary from RAM into reg B
@0x2D   0x09
//// if Y > first block?
@0x2E   0xA6 // True: branch to stage 2
@0x2F   0x34
@0x30   0x01 // False: load backward code into reg B
@0x31   0x03
@0x32   0x07 // False: goto backward calculation
@0x33   0x3A
// Y position check stage 2 //  
@0x34   0x01 // Read second YBoundary from RAM into reg B
@0x35   0x0A
//// if Y < third block?
@0x36   0xB6 // True: maintain op code and branch to read previous op code
@0x37   0x46
@0x38   0x01 // False: load forward code into reg B
@0x39   0x02
@0x3A   0x00 // Final calc: read op code into reg A
@0x3B   0x0B
@0x3C   0x04 // Final calc: A = A + B, save in A
@0x3D   0x02 // Final calc: write final op code
@0x3E   0x0B
@0x3F   0x02 // Write command from reg A to IR memory
@0x40   0x90 
@0x41   0x00 // Read empty byte
@0x42   0x06 
@0x43   0x02 // Reset IR op code
@0x44   0x0B
@0x45   0x08 // GOTO_IDLE and wait for interrupts
@0x46   0x00 // Read previous op code
@0x47   0x0B
@0x48   0x07 // Go to write IR
@0x49   0x3F

// vga cont..

