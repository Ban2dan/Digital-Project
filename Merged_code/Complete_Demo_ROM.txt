// VGA Section
// incrementing Hcounter
@0x00   0x00 // Read Hcounter to regA
@0x01   0x0C
@0x02   0x01 // Read constant value 159 into regB
@0x03   0x0D 
@0x04   0x96 // If HCounter = 159 jump to address 0x0B
@0x05   0x0B 
@0x06   0x54 // increment Hcounter in Reg A
@0x07   0x02 // Write reg A to Hcounter in Mem (RAM)
@0x08   0x0C
@0x09   0x07 // Go to address 0x20 
@0x0A   0x20
// incrementing Vcounter
@0x0B   0x00 // Read Vcounter into Reg A
@0x0C   0x0E 
@0x0D   0x01 // Read constant value 119 into reg B
@0x0E   0x0F
@0x0F   0x96 // If VCounter = 119 jump to 0x1A
@0x10   0x1A 
@0x11   0x54 // increment Vcounter in Reg A
@0x12   0x02 // Write reg A to Vcounter in Mem (RAM)
@0x13   0x0E 
@0x14   0x00 // Read constant value 0 into Reg A
@0x15   0x10 
@0x16   0x02 // Write reg A = 0 into Hcounter in Mem (RAM)
@0x17   0x0C
@0x18   0x07 // Go to address 0x20 
@0x19   0x20 
// finish scan
@0x1A   0x00 // Read constant value 0 into reg A
@0x1B   0x10
@0x1C   0x02 // Write reg A = 0 into Hcounter in Mem (RAM) 
@0x1D   0x0C 
@0x1E   0x02 // Write reg A = 0 into Vcounter in Mem (RAM)
@0x1F   0x0E 
// checking horizontal borders and writing foreground
@0x20   0x00 // Read Vcounter value into Reg A
@0x21   0x0E
@0x22   0x01 // Read constant value 40 into Reg B
@0x23   0x09
@0x24   0x96 // If VCounter = 40 jump to Address 0x30
@0x25   0x30 
@0x26   0x01 // Read constant value 80 into Reg B
@0x27   0x0A 
@0x28   0x96 // If VCounter = 80 jump to address 0x30
@0x29   0x30
@0x2A   0x01 // Read constant value 1 into Reg B
@0x2B   0x11
@0x2C   0x03 // Write Reg B to High Address 0xB2 for VGA
@0x2D   0xB2
@0x2E   0x07 // Go to Address 0x36
@0x2F   0x36 
// writing horizontal border
@0x30   0x01 // Read constant value 0 to Reg B
@0x31   0x10
@0x32   0x03 // Write Reg B to High address 0xB2 for VGA
@0x33   0xB2 
@0x34   0x07 // Go to Address 0x4A
@0x35   0x4A
// checking vertical borders and writing foreground
@0x36   0x00 // Read Hcounter value into Reg A
@0x37   0x0C
@0x38   0x01 // Read constant value 50 into Reg B
@0x39   0x07
@0x3A   0x96 // If HCounter = 50 jump to Address 0x46
@0x3B   0x46
@0x3C   0x01 // Read constant value 110 into Reg B
@0x3D   0x08
@0x3E   0x96 // If HCounter = 110 jump to address 0x46
@0x3F	0x46
@0x40   0x01 // Read constant value 1 into Reg B
@0x41   0x11
@0x42   0x03 // Write Reg B to High Address 0xB2 for VGA
@0x43   0xB2 
@0x44   0x07 // Goto Address 0x4A
@0x45   0x4A
// writing vertical border
@0x46   0x01 // Read constant value 0 into reg B
@0x47   0x10 
@0x48   0x03 // Write Reg B to High Address 0xB2 for VGA
@0x49   0xB2 
// writing X and Y
@0x4A   0x00 // Read Hcounter value into Reg A
@0x4B   0x0C 
@0x4C   0x02 // Write A to Base Address 0xB0 for VGA
@0x4D   0xB0 
@0x4E   0x01 // Read Vcounter value into regB
@0x4F   0x0E 
@0x50   0x03 // Write regB to Address 0xB1 for VGA
@0x51   0xB1
@0x52   0x01 // Read maximum value of HCounter (159) into reg B
@0x53   0x0D
@0x54   0xB6 // If current HCounter value less than maximum loop VGA section
@0x55   0x00
@0x56   0x00 // Read Vcounter into reg A
@0x57   0x0E
@0x58   0x01 // Read maximum value of VCounter (119) into Reg B
@0x59   0x0F
@0x5A   0xB6 // If current VCounter value less than maximum loop VGA section
@0x5B   0x00





//=====================
// PART A: Mouse/IR Section
//=====================
@0x5C   0x02 // Write Status Byte to LED memory
@0x5D   0xC0
@0x5E   0x00 // Read Switch byte into reg A
@0x5F   0x80
@0x60   0x00
@0x61   0x80
@0x62   0x02 // Write Switch Byte to ir memory
@0x63   0x91
@0x64   0x00 // Read previous MouseX Byte into reg A
@0x65   0x12
@0x66   0x01 // Read previous MouseY Byte into reg B
@0x67   0x13
@0x68	0x02 // write previous MouseX Byte to VGA
@0x69	0xB0
@0x6A	0x03 // write previous MouseY Byte to VGA
@0x6B	0xB1
@0x6C   0x00 // Load previous pixel value to reg A
@0x6D   0x14
@0x6E   0x02 // Write previous pixel value from reg A to VGA high address
@0x6F   0xB2
@0x70   0x00  // Read MouseX Byte into reg A
@0x71   0xA1
@0x72   0x01  // Read MouseY Byte to reg B
@0x73   0xA2
@0x74   0x02 // Save MouseX Byte to RAM
@0x75   0x12
@0x76   0x03 // Save MouseY Byte to RAM
@0x77   0x13
@0x78   0x02 // Write MouseX byte to 7-seg mem base address
@0x79   0xD0
@0x7A   0x03 // Write MouseY byte to 7-seg mem base address
@0x7B   0xD1
@0x7C   0x02 // Write Mouse X byte to VGA memory base address
@0x7D   0xB0
@0x7E   0x03 // Write Mouse Y byte to VGA memory middle address
@0x7F   0xB1
@0x80   0x00 // Load previous pixel value
@0x81   0xB2
@0x82   0x02 // Save previous pixel value to RAM
@0x83   0x14
@0x84   0x00 // Load a 0 to reg A
@0x85   0x10
@0x86   0x02 // Write a 0 from reg A to VGA memory high address
@0x87   0xB2
@0x88   0x08 // Go to IDLE and wait for interrupts

// X position check stage 1 //
@0x89   0x00 // Read saved mouse X from RAM into reg A (to be deleted)
@0x8A   0x00
@0x8B   0x01 // Read first XBoundary from RAM into reg B
@0x8C   0x07
//// if X > first block?
@0x8D   0xA6 // True: branch to stage 2
@0x8E   0x95
@0x8F   0x01 // False: load left code into reg B
@0x90   0x04
@0x91   0x03 // False: write reg B (left) value to op code
@0x92   0x0B
@0x93   0x07 // False: goto Y position check stage 1
@0x94   0x9D
// X position check stage 2 // 
@0x95   0x01 // Read second XBoundary from RAM into reg B
@0x96   0x08
//// if X < third block?  
@0x97   0xB6 // True: maintain op code 0 and branch to Y position check stage 1
@0x98   0x9D
@0x99   0x01 // False: load right code into reg B
@0x9A   0x05
@0x9B   0x03 // False: write reg B (Right) value to op code
@0x9C   0x0B
////// False: goto Y position check stage 1
// Y position check stage 1 //
@0x9D   0x00 // Read saved mouse Y from RAM into reg A
@0x9E   0x01
@0x9F   0x01 // Read first YBoundary from RAM into reg B
@0xA0   0x09
//// if Y > first block?
@0xA1   0xA6 // True: branch to stage 2
@0xA2   0xA7
@0xA3   0x01 // False: load backward code into reg B
@0xA4   0x03
@0xA5   0x07 // False: goto backward calculation
@0xA6   0xAD
// Y position check stage 2 //  
@0xA7   0x01 // Read second YBoundary from RAM into reg B
@0xA8   0x0A
//// if Y < third block?
@0xA9   0xB6 // True: maintain op code and branch to read previous op code
@0xAA   0xB9
@0xAB   0x01 // False: load forward code into reg B
@0xAC   0x02
@0xAD   0x00 // Final calc: read op code into reg A
@0xAE   0x0B
@0xAF   0x04 // Final calc: A = A + B, save in A
@0xB0   0x02 // Final calc: write final op code
@0xB1   0x0B
@0xB2   0x02 // Write command from reg A to IR memory
@0xB3   0x90 
@0xB4   0x00 // Read empty byte
@0xB5   0x06 
@0xB6   0x02 // Reset IR op code
@0xB7   0x0B
@0xB8   0x08 // GOTO_IDLE and wait for interrupts
@0xB9   0x00 // Read previous op code
@0xBA   0x0B
@0xBB   0x07 // Go to write IR
@0xBC   0xB2

// Interrupt jumps
@0xFE	0x89	// Timer interrupt	
@0xFF	0x5C	// Mouse interrupt
